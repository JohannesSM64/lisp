;;; Gosu Yatzy
;;; Written by Johannes LangÃ¸y, December 2013
(load "utils")

(defun numbers (n dice)
  (and (<= 1 (count n dice))
       (* n (count n dice))))

(defun pair (dice)
  (let ((s nil))
    (dolist (n '(6 5 4 3 2 1))
      (when (<= 2 (count n dice))
        (setf s (reduce #'+ (subseq (remove-if (lambda (x)
                                                 (not (= x n))) dice)
                                    0 2)))
        (return-from nil)))
    s))

(defun two-pairs (dice)
  (let* ((l (mapcar (lambda (n) (list n (count n dice)))
                    '(1 2 3 4 5 6))))
    (when (= 2 (count 2 (mapcar #'cadr l)))
      (reduce #'+
              (remove-if #'null (mapcar (lambda (x)
                                          (if (= (cadr x) 2)
                                            (* (car x) (cadr x))))
                                        l))))))

(defun three-alike (dice)
  (let ((s nil))
    (dolist (n '(6 5 4 3 2 1))
      (when (<= 3 (count n dice))
        (setf s (reduce #'+ (subseq (remove-if (lambda (x)
                                                 (not (= x n))) dice)
                                    0 3)))
        (return-from nil)))
    s))

(defun four-alike (dice)
  (let ((s nil))
    (dolist (n '(6 5 4 3 2 1))
      (when (<= 4 (count n dice))
        (setf s (reduce #'+ (subseq (remove-if (lambda (x)
                                                 (not (= x n))) dice)
                                    0 4)))
        (return-from nil)))
    s))

(defun small-straight (dice)
  (unless (member nil (mapcar (lambda (n) (find n dice))
                              '(1 2 3 4 5)))
    15))

(defun large-straight (dice)
  (unless (member nil (mapcar (lambda (n) (find n dice))
                              '(2 3 4 5 6)))
    20))

(defun full-house (dice)
  (let* ((l (mapcar (lambda (n) (list n (count n dice)))
                    '(1 2 3 4 5 6)))
         (lc (mapcar #'cadr l)))
    (when (and (find 2 lc) (find 3 lc))
      (reduce #'+
              (remove-if #'null (mapcar (lambda (x)
                                          (if (member (cadr x) '(2 3))
                                            (* (car x) (cadr x))))
                                        l))))))

(defun chance (dice)
  (reduce #'+ dice))

(defun yatzy (dice)
  (when (apply #'= dice)
    50))

(defun check-all (dice)
  `((ones ,(numbers 1 dice))
    (twos ,(numbers 2 dice))
    (threes ,(numbers 3 dice))
    (fours ,(numbers 4 dice))
    (fives ,(numbers 5 dice))
    (sixes ,(numbers 6 dice))
    (pair ,(pair dice))
    (two-pairs ,(two-pairs dice))
    (three-alike ,(three-alike dice))
    (four-alike ,(four-alike dice))
    (small-straight ,(small-straight dice))
    (large-straight ,(large-straight dice))
    (full-house ,(full-house dice))
    (chance ,(chance dice))
    (yatzy ,(yatzy dice))))

(defun remove-unfulfilled (checks)
  (remove-if (lambda (x) (null (cadr x)))
             checks))

;; Imperative part
(defun roll-dice (amount)
  (loop repeat amount collect (1+ (random 6))))

(defun game-loop ()
  (defvar *score* 0)
  (setf *dice* nil)
  (setf *checks* nil)
  (format t "Welcome to Gosu Yatzy.~%")
  (format t "Hit RET to roll your dice.~%")
  (read-line)
  (loop repeat 2 do
        (setf *dice* (append *dice* (roll-dice (- 5 (length *dice*)))))
        (princ *dice*)
        (fresh-line)
        (format t "Enter which dice to keep.~%")
        (setf *dice* (read *standard-input*))
        (if (= 5 (length *dice*))
          (return-from nil)))
  (setf *dice* (append *dice* (roll-dice (- 5 (length *dice*)))))
  (princ *dice*)
  (setf *checks* (remove-unfulfilled (check-all *dice*))))
